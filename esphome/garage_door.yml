---
#<<: !include secrets.yaml

esphome:
  name: garage_door
  platform: ESP32
  board: esp-wrover-kit

wifi:
  networks:
    - ssid: !secret wifi_ssid1
      password: !secret wifi_passwd1
    - ssid: !secret wifi_ssid2
      password: !secret wifi_passwd2

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Garage Door Fallback Hotspot"
    password: !secret wifi_ap_passwd

captive_portal:

# Enable logging
logger:

debug:

# Enable Home Assistant API
api:

web_server:

ota:

time:
  - platform: homeassistant
    id: esp_time
  - platform: sntp
    id: ntp_time
    timezone: Europe/Moscow

#esp32_ble_tracker:

uart:
#  - id: uart
#    tx_pin: 1
#    rx_pin: 3
#    baud_rate: 115200
#    stop_bits: 1
  - id: uart_cc
    tx_pin: 16
    rx_pin: 17
    baud_rate: 115200
    stop_bits: 1
  - id: uart_pzem
    tx_pin: 21
    rx_pin: 22
    baud_rate: 9600
    stop_bits: 2

modbus:
  uart_id: uart_pzem
  id: modbus_pzem

spi:
  clk_pin: 14
  mosi_pin: 13
  miso_pin: 12

#display:
#  - platform: waveshare_epaper
#    cs_pin: 23
#    dc_pin: 25
#    busy_pin:
#      number: 32
#      mode: INPUT_PULLUP
#    reset_pin: 0
#    model: 2.90in-b
#    #full_update_every: 30
#    update_interval: 60s
#    lambda: |-
#      it.print(0, 0, id(font_m14), "Hello World!");
#      //it.fill(COLOR_ON);
#
#font:
#  - file: UbuntuMono-R.ttf
#    id: font_m14
#    size: 14

globals:
  - id: prev_door_operation
    type: CoverOperation
    restore_value: no
    initial_value: COVER_OPERATION_IDLE

  - id: door_open_cnt
    type: uint32_t
    restore_value: yes
    initial_value: '0'

  - id: door_close_cnt
    type: uint32_t
    restore_value: yes
    initial_value: '0'

  - id: door_blocked1_cnt
    type: uint32_t
    restore_value: yes
    initial_value: '0'

binary_sensor:
  - platform: status
    name: Garage Door Status

  #- platform: gpio
  #  pin: 27
  #  id: s2_isr

  - platform: gpio
    id: blk1
    name: "Safety block 1"
    pin:
      number: 33
      inverted: false  # open circuit => block
    filters:
      - delayed_on: 10ms
    on_press:
      then:
        - lambda: !lambda |
            id(prev_door_operation) = id(door_cover).current_operation;
            id(door_blocked1_cnt) += 1;
        - logger.log:
            format: "blk1: activated: stopping cover"
            level: INFO
        - cover.stop: door_cover
        - logger.log:
            format: "blk1: cover stopped"
            level: INFO
    on_release:
      then:
        - logger.log:
            format: "blk1: deactivated: continue cover operation: %s"
            level: INFO
            args:
              - &prev_state_str "cover_operation_to_str(id(prev_door_operation))"
        - lambda: !lambda |
            auto call = id(door_cover).make_call();
            if (id(prev_door_operation) == COVER_OPERATION_OPENING) {
              call.set_command_open();
              call.perform();
            } else if (id(prev_door_operation) == COVER_OPERATION_CLOSING) {
              call.set_command_close();
              call.perform();
            }
        - logger.log:
            format: "blk1: operation restored"
            level: INFO

  - platform: gpio
    id: blk2
    name: "Safety block 2 / Open/Close"
    pin:
      number: 34
      inverted: true  # use as Open/Close button
    filters:
      - delayed_on: 10ms
    on_press:
      then:
        - logger.log: "blk2: activated"
        - script.execute: open_close_stop_button_scr

  - platform: gpio
    id: rsns
    name: "Door closed end stop"
    pin:
      number: 35
      inverted: true
    filters:
      - delayed_on: 10ms
    on_press:
      then:
        - logger.log:
            format: "rsns: activated. wait 10s to give a time to fully unroll the door."
            level: INFO
        - delay: 10s
        - logger.log:
            format: "rsns: setting door state as closed."
            level: INFO
        - lambda: !lambda |
            if (id(door_cover).current_operation != COVER_OPERATION_OPENING) {
              id(door_cover).position = COVER_CLOSED;
              id(door_cover).publish_state(true);
            }
        - logger.log:
            format: "rsns: done"
            level: INFO

text_sensor:
  - platform: wifi_info
    ssid:
      name: SSID
    bssid:
      name: BSSID

  - platform: version
    name: "ESPHome version"

sensor:
  - platform: wifi_signal
    name: "WiFi Signal Sensor"
    update_interval: 10s

  - platform: esp32_hall
    name: "ESP32 Hall Sensor"
    update_interval: 10s

  - platform: uptime
    name: "Uptime"

  - platform: pzemac
    modbus_id: modbus_pzem
    current:
      name: "Current"
    voltage:
      name: "Voltage"
    power:
      name: "Power"
    frequency:
      name: "Frequency"
    power_factor:
      name: "Power Factor"
    update_interval: 10s

  - platform: template
    name: "Door Open Count"
    lambda: !lambda |
      return float(id(door_open_cnt));
    update_interval: 10s

  - platform: template
    name: "Door Close Count"
    lambda: !lambda |
      return float(id(door_close_cnt));
    update_interval: 10s

  - platform: template
    name: "Door Blocked 1 Count"
    lambda: !lambda |
      return float(id(door_blocked1_cnt));
    update_interval: 10s

switch:
  - platform: gpio
    name: Door Motor Up
    #internal: true
    id: k1_up
    pin: 2
    # NOTE: hardware has lock from that,
    #       K1 NC powers K2, so we always may open the door.
    interlock: &relay_lock
      - k1_up
      - k2_down
    restore_mode: always off

  - platform: gpio
    name: Door Motor Down
    #internal: true
    id: k2_down
    pin: 4
    interlock: *relay_lock
    restore_mode: always off

cover:
  # NOTE: my roller have built-in endstops,
  #       so it's possible to detect that operation is done
  #       by checking that PZEM Current < 0.1 A
  #
  #       blk1 used to STOP motion
  #       because something blocks gate, e.g. a car.
  #       if problem resolves - continue operation.
  #
  #       blk2 used as Open/Close/Stop button.
  #
  #       rsns inductive endstop detects when door is closed.
  - platform: time_based
    id: door_cover
    name: Garage Door
    device_class: garage

    open_duration: 2min
    open_action:
      - if: &blk1_if
          condition:
            binary_sensor.is_on: blk1
          then:
            - logger.log:
                format: "door_cover: blk1 activated, operations blocked."
                level: WARN
            - cover.stop: door_cover
          else:
            - switch.turn_on: k1_up
      - lambda: !lambda |
          id(door_open_cnt) += 1;

    close_duration: 2min
    close_action:
      - if:
          <<: *blk1_if
          else:
            - switch.turn_on: k2_down
      - lambda: !lambda |
          id(door_close_cnt) += 1;

    stop_action:
      - switch.turn_off: k1_up
      - switch.turn_off: k2_down

    # NOTE: my roller have it, but i do not want to leave
    #       motor energized.
    has_built_in_endstop: false

script:
  - id: open_close_stop_button_scr
    #name: "Open/Close/Stop Door"
    then:
      - logger.log:
          format: "open/close/stop activated: prev state: %s"
          level: INFO
          args: [*prev_state_str]
      - lambda: !lambda |
          const auto op = id(door_cover).current_operation;
          auto call = id(door_cover).make_call();
          if (op != COVER_OPERATION_IDLE) {
            id(prev_door_operation) = op;
            call.set_command_stop();
          } else {
            if (id(prev_door_operation) == COVER_OPERATION_CLOSING ||
                id(door_cover).is_fully_closed()) {
              call.set_command_open();
            } else {
              call.set_command_close();
            }
          }
          call.perform();
      - logger.log:
          format: "open/close/stop: operation performed"
          level: INFO

  - id: open_stop_button_scr
    #name: "Open/Stop Door"
    then:
      - logger.log:
          format: "open/stop: activated"
          level: INFO
      - if: &scr_if
          condition:
            lambda: !lambda |
              const auto op = id(door_cover).current_operation;
              return op != COVER_OPERATION_IDLE || op != COVER_OPERATION_OPENING;
          then:
            - cover.stop: door_cover
          else:
            - cover.open: door_cover
      - logger.log:
          format: "open/stop: operation performed"
          level: INFO

  - id: close_stop_button_scr
    #name: "Close/Stop Door"
    then:
      - logger.log:
          format: "close/stop: activated"
          level: INFO
      - if:
          <<: *scr_if
          condition:
            lambda: !lambda |
              const auto op = id(door_cover).current_operation;
              return op != COVER_OPERATION_IDLE || op != COVER_OPERATION_CLOSING;
          else:
            - cover.close: door_cover
      - logger.log:
          format: "close/stop: operation performed"
          level: INFO
